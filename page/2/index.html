<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"halomzh.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="halomzh.github.io">
<meta property="og:url" content="https://halomzh.github.io/page/2/index.html">
<meta property="og:site_name" content="halomzh.github.io">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="halomzh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://halomzh.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>halomzh.github.io</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="halomzh.github.io" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">halomzh.github.io</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-origin">

    <a href="/origin/" rel="section"><i class="fa-origin fa-fw"></i>origin</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://halomzh.github.io/2020/09/18/%E5%9F%BA%E4%BA%8EAnnotation%E7%9A%84IOC%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="halomzh">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="halomzh.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/%E5%9F%BA%E4%BA%8EAnnotation%E7%9A%84IOC%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">基于Annotation的IOC初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-18 13:07:24" itemprop="dateCreated datePublished" datetime="2020-09-18T13:07:24+08:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-25 17:35:58" itemprop="dateModified" datetime="2020-09-25T17:35:58+08:00">2020-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-IOC-容器注解"><a href="#Spring-IOC-容器注解" class="headerlink" title="Spring IOC 容器注解"></a>Spring IOC 容器注解</h1><p>Spring IOC 容器对于类级别的注解和类内部的注解分以下两种处理策略：</p>
<p>1)、类级别的注解：如@Component、@Repository、@Controller、@Service 以及JavaEE6 的@ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规则扫描读取注解Bean 定义类，并将其注册到Spring IOC 容器中。</p>
<p>2)、类内部的注解：如@Autowire、@Value、@Resource 以及EJB 和WebService 相关的注解等，都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过Bean 后置注解处理器解析Bean 内部的注解。</p>
<h1 id="定位Bean-扫描路径"><a href="#定位Bean-扫描路径" class="headerlink" title="定位Bean 扫描路径"></a>定位Bean 扫描路径</h1><p>Spring 中管理注解Bean 定义的容器有两个： AnnotationConfigApplicationContext 和AnnotationConfigWebApplicationContex。</p>
<p>这两个类是专门处理Spring 注解方式配置的容器，直接依赖于注解作为容器配置信息来源的IOC 容器。AnnotationConfigWebApplicationContext 是AnnotationConfigApplicationContext 的Web 版本。</p>
<p>现在我们以AnnotationConfigApplicationContext 为例看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存一个读取注解的Bean 定义读取器，并将其设置到容器中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">    <span class="comment">//保存一个扫描指定类路径中注解Bean 定义的扫描器，并将其设置到容器中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数，初始化一个空容器，容器不包含任何Bean 信息，需要在稍后通过调用其register()</span></span><br><span class="line">    <span class="comment">//方法注册配置类，并调用refresh()方法刷新容器，触发容器对注解Bean 的载入、解析和注册过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的Bean 自动注册到容器中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        register(annotatedClasses);</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的Spring Bean，将其注册到容器中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        scan(basePackages);</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setEnvironment(environment);</span><br><span class="line">        <span class="keyword">this</span>.reader.setEnvironment(environment);</span><br><span class="line">        <span class="keyword">this</span>.scanner.setEnvironment(environment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为容器的注解Bean 读取器和注解Bean 扫描器设置Bean 名称产生器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanNameGenerator</span><span class="params">(BeanNameGenerator beanNameGenerator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        <span class="keyword">this</span>.scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        getBeanFactory().registerSingleton(</span><br><span class="line">                AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为容器的注解Bean 读取器和注解Bean 扫描器设置作用范围元信息解析器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScopeMetadataResolver</span><span class="params">(ScopeMetadataResolver scopeMetadataResolver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">        <span class="keyword">this</span>.scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为容器注册一个要被处理的注解Bean，新注册的Bean，必须手动调用容器的</span></span><br><span class="line">    <span class="comment">//refresh()方法刷新容器，触发容器对新注册的Bean 的处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(annotatedClasses, <span class="string">&quot;At least one annotated class must be specified&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用</span></span><br><span class="line">    <span class="comment">//refresh()方法刷新容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码分析，我们可以看啊到Spring 对注解的处理分为两种方式：</p>
<p>1)、直接将注解Bean 注册到容器中<br>可以在初始化容器时注册；也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容器，使得容器对注册的注解Bean 进行处理。</p>
<p>2)、通过扫描指定的包及其子包下的所有类<br>在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解Bean，则需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的Bean 进行处理。</p>
<p>接下来，将会对两种处理方式详细分析其实现过程。</p>
<h1 id="读取Annotation-元数据"><a href="#读取Annotation-元数据" class="headerlink" title="读取Annotation 元数据"></a>读取Annotation 元数据</h1><p>当创建注解处理容器时，如果传入的初始参数是具体的注解Bean 定义类时，注解容器读取并注册。</p>
<h2 id="1-、AnnotationConfigApplicationContext-通过调用注解Bean-定义读取器"><a href="#1-、AnnotationConfigApplicationContext-通过调用注解Bean-定义读取器" class="headerlink" title="1)、AnnotationConfigApplicationContext 通过调用注解Bean 定义读取器"></a>1)、AnnotationConfigApplicationContext 通过调用注解Bean 定义读取器</h2><p>AnnotatedBeanDefinitionReader 的register()方法向容器注册指定的注解Bean，注解Bean 定义读取器向容器注册注解Bean 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册多个注解Bean 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">        registerBean(annotatedClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个注解Bean 定义类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(annotatedClass, instanceSupplier, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;T&gt; annotatedClass, String name, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(annotatedClass, instanceSupplier, name, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean 定义读取器注册注解Bean 定义的入口方法</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean 定义读取器向容器注册注解Bean 定义类</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; annotatedClass, String name, Class&lt;? extends Annotation&gt;... qualifiers)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(annotatedClass, <span class="keyword">null</span>, name, qualifiers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean 定义读取器向容器注册注解Bean 定义类</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; annotatedClass, <span class="meta">@Nullable</span> Supplier&lt;T&gt; instanceSupplier, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据指定的注解Bean 定义类，创建Spring 容器中对注解Bean 的封装的数据结构</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line">    <span class="comment">//解析注解Bean 定义的作用域，若@Scope(&quot;prototype&quot;)，则Bean 为原型类型；</span></span><br><span class="line">    <span class="comment">//若@Scope(&quot;singleton&quot;)，则Bean 为单态类型</span></span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    <span class="comment">//为注解Bean 定义设置作用域</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    <span class="comment">//为注解Bean 定义生成Bean 名称</span></span><br><span class="line">    String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line">    <span class="comment">//处理注解Bean 定义中的通用注解</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">    <span class="comment">//如果在向容器注册注解Bean 定义时，使用了额外的限定符注解，则解析限定符注解。</span></span><br><span class="line">    <span class="comment">//主要是配置的关于autowiring 自动依赖注入装配的限定条件，即@Qualifier 注解</span></span><br><span class="line">    <span class="comment">//Spring 自动依赖注入装配默认是按类型装配，如果使用@Qualifier 则按名称</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">            <span class="comment">//如果配置了@Primary 注解，设置该Bean 为autowiring 自动依赖注入装//配时的首选</span></span><br><span class="line">            <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果配置了@Lazy 注解，则设置该Bean 为非延迟初始化，如果没有配置，</span></span><br><span class="line">            <span class="comment">//则该Bean 为预实例化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果使用了除@Primary 和@Lazy 以外的其他注解，则为该Bean 添加一</span></span><br><span class="line">            <span class="comment">//个autowiring 自动依赖注入装配限定符，该Bean 在进autowiring</span></span><br><span class="line">            <span class="comment">//自动依赖注入装配时，根据名称装配限定符指定的Bean</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">        customizer.customize(abd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个指定Bean 名称的Bean 定义对象，封装注解Bean 定义类数据</span></span><br><span class="line">    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">    <span class="comment">//根据注解Bean 定义类中配置的作用域，创建相应的代理对象</span></span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,</span><br><span class="line">            <span class="keyword">this</span>.registry);</span><br><span class="line">    <span class="comment">//向IOC 容器注册注解Bean 类定义对象</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码我们可以看出，注册注解Bean 定义类的基本步骤：<br>a、需要使用注解元数据解析器解析注解Bean 中关于作用域的配置。<br>b、使用AnnotationConfigUtils 的processCommonDefinitionAnnotations()方法处理注解Bean 定义类中通用的注解。<br>c、使用AnnotationConfigUtils 的applyScopedProxyMode()方法创建对于作用域的代理对象。<br>d、通过BeanDefinitionReaderUtils 向容器注册Bean。</p>
<p>下面我们继续分析这4 步的具体实现过程</p>
<h2 id="2-、AnnotationScopeMetadataResolver-解析作用域元数据"><a href="#2-、AnnotationScopeMetadataResolver-解析作用域元数据" class="headerlink" title="2)、AnnotationScopeMetadataResolver 解析作用域元数据"></a>2)、AnnotationScopeMetadataResolver 解析作用域元数据</h2><p>AnnotationScopeMetadataResolver 通过resolveScopeMetadata()方法解析注解Bean 定义类的作用域元信息，即判断注册的Bean 是原生类型(prototype)还是单态(singleton)类型，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析注解Bean 定义类中的作用域元信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">        <span class="comment">//从注解Bean 定义类的属性中查找属性为”Scope”的值，即@Scope 注解的值</span></span><br><span class="line">        <span class="comment">//annDef.getMetadata().getAnnotationAttributes 方法将Bean</span></span><br><span class="line">        <span class="comment">//中所有的注解和注解的值存放在一个map 集合中</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="comment">//将获取到的@Scope 注解的值设置到要返回的对象中</span></span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            <span class="comment">//获取@Scope 注解中的proxyMode 属性值，在创建代理对象时会用到</span></span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">&quot;proxyMode&quot;</span>);</span><br><span class="line">            <span class="comment">//如果@Scope 的proxyMode 属性为DEFAULT 或者NO</span></span><br><span class="line">            <span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                <span class="comment">//设置proxyMode 为NO</span></span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为返回的元数据设置proxyMode</span></span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回解析的作用域元信息对象</span></span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的annDef.getMetadata().getAnnotationAttributes()方法就是获取对象中指定类型的注解的值。</p>
<h2 id="3-、AnnotationConfigUtils-处理注解Bean-定义类中的通用注解"><a href="#3-、AnnotationConfigUtils-处理注解Bean-定义类中的通用注解" class="headerlink" title="3)、AnnotationConfigUtils 处理注解Bean 定义类中的通用注解"></a>3)、AnnotationConfigUtils 处理注解Bean 定义类中的通用注解</h2><p>AnnotationConfigUtils 类的processCommonDefinitionAnnotations()在向容器注册Bean 之前，首先对注解Bean 定义类中的通用Spring 注解进行处理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理Bean 定义中通用注解</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommonDefinitionAnnotations</span><span class="params">(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);</span><br><span class="line">    <span class="comment">//如果Bean 定义中有@Lazy 注解，则将该Bean 预实例化属性设置为@lazy 注解的值</span></span><br><span class="line">    <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (abd.getMetadata() != metadata) &#123;</span><br><span class="line">        lazy = attributesFor(abd.getMetadata(), Lazy.class);</span><br><span class="line">        <span class="keyword">if</span> (lazy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            abd.setLazyInit(lazy.getBoolean(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Bean 定义中有@Primary 注解，则为该Bean 设置为autowiring 自动依赖注入装配的首选对象</span></span><br><span class="line">    <span class="keyword">if</span> (metadata.isAnnotated(Primary.class.getName())) &#123;</span><br><span class="line">        abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Bean 定义中有@ DependsOn 注解，则为该Bean 设置所依赖的Bean 名称，</span></span><br><span class="line">    <span class="comment">//容器将确保在实例化该Bean 之前首先实例化所依赖的Bean</span></span><br><span class="line">    AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);</span><br><span class="line">    <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        abd.setDependsOn(dependsOn.getStringArray(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (abd <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span><br><span class="line">        AnnotationAttributes role = attributesFor(metadata, Role.class);</span><br><span class="line">        <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">            absBd.setRole(role.getNumber(<span class="string">&quot;value&quot;</span>).intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        AnnotationAttributes description = attributesFor(metadata, Description.class);</span><br><span class="line">        <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">            absBd.setDescription(description.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-、AnnotationConfigUtils-根据注解Bean-定义类中配置的作用域为其应用相应的代理策略"><a href="#4-、AnnotationConfigUtils-根据注解Bean-定义类中配置的作用域为其应用相应的代理策略" class="headerlink" title="4)、AnnotationConfigUtils 根据注解Bean 定义类中配置的作用域为其应用相应的代理策略"></a>4)、AnnotationConfigUtils 根据注解Bean 定义类中配置的作用域为其应用相应的代理策略</h2><p>AnnotationConfigUtils 类的applyScopedProxyMode()方法根据注解Bean 定义类中配置的作用域@Scope 注解的值，为Bean 定义应用相应的代理模式，主要是在Spring 面向切面编程(AOP)中使用。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据作用域为Bean 应用引用的代码模式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取注解Bean 定义类中@Scope 注解的proxyMode 属性值</span></span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">//如果配置的@Scope 注解的proxyMode 属性值为NO，则不应用代理模式</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取配置的@Scope 注解的proxyMode 属性值，如果为TARGET_CLASS</span></span><br><span class="line">    <span class="comment">//则返回true，如果为INTERFACES，则返回false</span></span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="comment">//为注册的Bean 创建相应模式的代理对象</span></span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段为Bean 引用创建相应模式的代理，这里不做深入的分析。</p>
<h2 id="5-、BeanDefinitionReaderUtils-向容器注册Bean"><a href="#5-、BeanDefinitionReaderUtils-向容器注册Bean" class="headerlink" title="5)、BeanDefinitionReaderUtils 向容器注册Bean"></a>5)、BeanDefinitionReaderUtils 向容器注册Bean</h2><p>BeanDefinitionReaderUtils 主要是校验BeanDefinition 信息，然后将Bean 添加到容器中一个管理BeanDefinition 的HashMap 中。</p>
<h1 id="扫描指定包并解析为BeanDefinition"><a href="#扫描指定包并解析为BeanDefinition" class="headerlink" title="扫描指定包并解析为BeanDefinition"></a>扫描指定包并解析为BeanDefinition</h1><p>当创建注解处理容器时，如果传入的初始参数是注解Bean 定义类所在的包时，注解容器将扫描给定的包及其子包，将扫描到的注解Bean 定义载入并注册。</p>
<h2 id="1-、ClassPathBeanDefinitionScanner-扫描给定的包及其子包"><a href="#1-、ClassPathBeanDefinitionScanner-扫描给定的包及其子包" class="headerlink" title="1)、ClassPathBeanDefinitionScanner 扫描给定的包及其子包"></a>1)、ClassPathBeanDefinitionScanner 扫描给定的包及其子包</h2><p>AnnotationConfigApplicationContext 通过调用类路径Bean 定义扫描器ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个类路径Bean 定义扫描器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(registry, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为容器创建一个类路径Bean 定义扫描器，并指定是否使用默认的扫描过滤规则。</span></span><br><span class="line">    <span class="comment">//即Spring 默认扫描配置：@Component、@Repository、@Service、@Controller</span></span><br><span class="line">    <span class="comment">//注解的Bean，同时也支持JavaEE6 的@ManagedBean 和JSR-330 的@Named 注解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(registry, useDefaultFilters, environment,</span><br><span class="line">                (registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="keyword">boolean</span> useDefaultFilters,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">        <span class="comment">//为容器设置加载Bean 定义的注册器</span></span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">        <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">            registerDefaultFilters();</span><br><span class="line">        &#125;</span><br><span class="line">        setEnvironment(environment);</span><br><span class="line">        <span class="comment">//为容器设置资源加载器</span></span><br><span class="line">        setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用类路径Bean 定义扫描器入口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取容器中已经注册的Bean 个数</span></span><br><span class="line">        <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//启动扫描器扫描给定包</span></span><br><span class="line">        doScan(basePackages);</span><br><span class="line">        <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">        <span class="comment">//注册注解配置(Annotation config)处理器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">            AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回注册的Bean 个数</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类路径Bean 定义扫描器扫描给定包及其子包</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个集合，存放扫描到Bean 定义的封装类</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历扫描所有给定的包</span></span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            <span class="comment">//调用父类ClassPathScanningCandidateComponentProvider 的方法</span></span><br><span class="line">            <span class="comment">//扫描给定类路径，获取符合条件的Bean 定义</span></span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">            <span class="comment">//遍历扫描到的Bean</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                <span class="comment">//获取Bean 定义类中@Scope 注解的值，即获取Bean 的作用域</span></span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                <span class="comment">//为Bean 设置注解配置的作用域</span></span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                <span class="comment">//为Bean 生成名称</span></span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="comment">//如果扫描到的Bean 不是Spring 的注解Bean，则为Bean 设置默认值，</span></span><br><span class="line">                <span class="comment">//设置Bean 的自动依赖注入装配属性等</span></span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果扫描到的Bean 是Spring 的注解Bean，则处理其通用的Spring 注解</span></span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    <span class="comment">//处理注解Bean 中通用的注解，在分析注解Bean 定义类读取器时已经分析过</span></span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据Bean 名称检查指定的Bean 是否需要在容器中注册，或者在容器中冲突</span></span><br><span class="line">                <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    <span class="comment">//根据注解中配置的作用域，为Bean 应用相应的代理模式</span></span><br><span class="line">                    definitionHolder =</span><br><span class="line">                            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,</span><br><span class="line">                                    <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    <span class="comment">//向容器注册扫描到的Bean</span></span><br><span class="line">                    registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类路径Bean 定义扫描器ClassPathBeanDefinitionScanner 主要通过findCandidateComponents()方法调用其父类ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下的类。</p>
<h2 id="2-、ClassPathScanningCandidateComponentProvider-扫描给定包及其子包的类"><a href="#2-、ClassPathScanningCandidateComponentProvider-扫描给定包及其子包的类" class="headerlink" title="2)、ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类"></a>2)、ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类</h2><p>ClassPathScanningCandidateComponentProvider 类的findCandidateComponents()方法具体实现扫描给定类路径包的功能，主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存过滤规则要包含的注解，即Spring 默认的@Component、@Repository、@Service、</span></span><br><span class="line">    <span class="comment">//@Controller 注解的Bean，以及JavaEE6 的@ManagedBean 和JSR-330 的@Named 注解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; includeFilters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存过滤规则要排除的注解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TypeFilter&gt; excludeFilters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，该方法在子类ClassPathBeanDefinitionScanner 的构造方法中被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(useDefaultFilters, <span class="keyword">new</span> StandardEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathScanningCandidateComponentProvider</span><span class="params">(<span class="keyword">boolean</span> useDefaultFilters, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果使用Spring 默认的过滤规则，则向容器注册过滤规则</span></span><br><span class="line">        <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">            registerDefaultFilters();</span><br><span class="line">        &#125;</span><br><span class="line">        setEnvironment(environment);</span><br><span class="line">        setResourceLoader(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向容器注册过滤规则</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向要包含的过滤规则中添加@Component 注解类，注意Spring 中@Repository</span></span><br><span class="line">        <span class="comment">//@Service 和@Controller 都是Component，因为这些注解都添加了@Component 注解</span></span><br><span class="line">        <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">        <span class="comment">//获取当前类的类加载器</span></span><br><span class="line">        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向要包含的过滤规则添加JavaEE6 的@ManagedBean 注解</span></span><br><span class="line">            <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">                    ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">            logger.debug(<span class="string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向要包含的过滤规则添加@Named 注解</span></span><br><span class="line">            <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">                    ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">            logger.debug(<span class="string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扫描给定类路径的包</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">            <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">addCandidateComponentsFromIndex</span><span class="params">(CandidateComponentsIndex index, String</span></span></span><br><span class="line"><span class="function"><span class="params">            basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存储扫描到的类的集合</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;String&gt; types = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (TypeFilter filter : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">                String stereotype = extractStereotype(filter);</span><br><span class="line">                <span class="keyword">if</span> (stereotype == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Failed to extract stereotype from &quot;</span> + filter);</span><br><span class="line">                &#125;</span><br><span class="line">                types.addAll(index.getCandidateTypes(basePackage, stereotype));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">            <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">            <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">                <span class="comment">//为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息</span></span><br><span class="line">                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);</span><br><span class="line">                <span class="comment">//如果扫描到的类符合容器配置的过滤规则</span></span><br><span class="line">                <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                    <span class="comment">//通过汇编(ASM)读取资源字节码中的Bean 定义元信息</span></span><br><span class="line">                    AnnotatedGenericBeanDefinition sbd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(</span><br><span class="line">                            metadataReader.getAnnotationMetadata());</span><br><span class="line">                    <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                            logger.debug(<span class="string">&quot;Using candidate component class from index: &quot;</span> + type);</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidates.add(sbd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                            logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + type);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Ignored because matching an exclude filter: &quot;</span> + type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断元信息读取器读取的类是否符合容器定义的注解过滤规则</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//如果读取的类的注解在排除注解过滤规则中，返回false</span></span><br><span class="line">        <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果读取的类的注解在包含的注解的过滤规则中，则返回ture</span></span><br><span class="line">        <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">                <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果读取的类的注解既不在排除规则，也不在包含规则中，则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注册注解BeanDefinition"><a href="#注册注解BeanDefinition" class="headerlink" title="注册注解BeanDefinition"></a>注册注解BeanDefinition</h1><p>AnnotationConfigWebApplicationContext 是AnnotationConfigApplicationContext 的Web 版，它们对于注解Bean 的注册和扫描是基本相同的，但是AnnotationConfigWebApplicationContext对注解Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解Bean 定义源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入注解Bean 定义资源</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为容器设置注解Bean 定义读取器</span></span><br><span class="line">    AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">//为容器设置类路径Bean 定义扫描器</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);</span><br><span class="line">    <span class="comment">//获取容器的Bean 名称生成器</span></span><br><span class="line">    BeanNameGenerator beanNameGenerator = getBeanNameGenerator();</span><br><span class="line">    <span class="comment">//为注解Bean 定义读取器和类路径扫描器设置Bean 名称生成器</span></span><br><span class="line">    <span class="keyword">if</span> (beanNameGenerator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line">        beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,</span><br><span class="line">                beanNameGenerator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取容器的作用域元信息解析器</span></span><br><span class="line">    ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();</span><br><span class="line">    <span class="comment">//为注解Bean 定义读取器和类路径扫描器设置作用域元信息解析器</span></span><br><span class="line">    <span class="keyword">if</span> (scopeMetadataResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">        scanner.setScopeMetadataResolver(scopeMetadataResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.annotatedClasses.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Registering annotated classes: [&quot;</span> +</span><br><span class="line">                    StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.annotatedClasses) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.register(<span class="keyword">this</span>.annotatedClasses.toArray(<span class="keyword">new</span> Class&lt;?&gt;[<span class="keyword">this</span>.annotatedClasses.size()]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.basePackages.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Scanning base packages: [&quot;</span> +</span><br><span class="line">                    StringUtils.collectionToCommaDelimitedString(<span class="keyword">this</span>.basePackages) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.scan(<span class="keyword">this</span>.basePackages.toArray(<span class="keyword">new</span> String[<span class="keyword">this</span>.basePackages.size()]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取容器定义的Bean 定义资源路径</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="comment">//如果定位的Bean 定义资源路径不为空</span></span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//使用当前容器的类加载器加载定位路径的字节码类文件</span></span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Successfully resolved class for [&quot;</span> + configLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                reader.register(clazz);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Could not load class for config location [&quot;</span> + configLocation +</span><br><span class="line">                            <span class="string">&quot;] - trying package scan. &quot;</span> + ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果容器类加载器加载定义路径的Bean 定义资源失败</span></span><br><span class="line">                <span class="comment">//则启用容器类路径扫描器扫描给定路径包及其子包中的类</span></span><br><span class="line">                <span class="keyword">int</span> count = scanner.scan(configLocation);</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;No annotated classes found for specified class/package [&quot;</span> + configLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Found &quot;</span> + count + <span class="string">&quot; annotated classes in package [&quot;</span> + configLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://halomzh.github.io/2020/09/18/%E5%9F%BA%E4%BA%8EXml%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="halomzh">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="halomzh.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/%E5%9F%BA%E4%BA%8EXml%E7%9A%84IOC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">基于Xml的IOC容器的初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-18 13:06:09" itemprop="dateCreated datePublished" datetime="2020-09-18T13:06:09+08:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-25 17:36:03" itemprop="dateModified" datetime="2020-09-25T17:36:03+08:00">2020-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>IOC 容器的初始化包括BeanDefinition 的Resource 定位、加载和注册这三个基本的过程。<br>其继承体系如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/24719542-02d12bd0140643ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ApplicationContext 允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于Bean 的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的Bean 定义环境。</p>
<h1 id="1、寻找入口"><a href="#1、寻找入口" class="headerlink" title="1、寻找入口"></a>1、寻找入口</h1><p>我们用的比较多的ClassPathXmlApplicationContext，通过main()方法启动:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>先看其构造函数的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实际调用的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="keyword">this</span>.refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有像AnnotationConfigApplicationContext 、FileSystemXmlApplicationContext 、<br>XmlWebApplicationContext 等都继承自父容器AbstractApplicationContext 主要用到了装饰器模式和策略模式，最终都是调用refresh()方法。</p>
<h1 id="2、获得配置路径"><a href="#2、获得配置路径" class="headerlink" title="2、获得配置路径"></a>2、获得配置路径</h1><p>在创建ClassPathXmlApplicationContext 容器时，构造方法做以下两项重要工作：</p>
<p>首先，调用父类容器的构造方法(super(parent)方法)为容器设置好Bean 资源加载器。</p>
<p>然后， 再调用父类AbstractRefreshableConfigApplicationContext 的setConfigLocations(configLocations)方法设置Bean 配置信息的定位路径。</p>
<p>通过追踪ClassPathXmlApplicationContext 的继承体系， 发现其父类的父类AbstractApplicationContext 中初始化IOC 容器所做的主要源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态初始化块，在整个容器创建过程中只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//为了避免应用程序在Weblogic8.1 关闭时出现类加载异常加载问题，加载IOC 容</span></span><br><span class="line">        <span class="comment">//器关闭事件(ContextClosedEvent)类</span></span><br><span class="line">        ContextClosedEvent.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        setParent(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个Spring Source 的加载器用于读入Spring Bean 配置信息</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//AbstractApplicationContext 继承DefaultResourceLoader，因此也是一个资源加载器</span></span><br><span class="line">        <span class="comment">//Spring 资源加载器，其getResource(String location)方法用于载入资源</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext 的默认构造方法中有调用PathMatchingResourcePatternResolver 的构造方法创建Spring 资源加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathMatchingResourcePatternResolver</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(resourceLoader, <span class="string">&quot;ResourceLoader must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//设置Spring 的资源加载器</span></span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置容器的资源加载器之后，接下来ClassPathXmlApplicationContext 执行setConfigLocations()方法通过调用其父类AbstractRefreshableConfigApplicationContext 的方法进行对Bean 配置信息的定位，该方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the config locations for this application context in init-param style,</span></span><br><span class="line"><span class="comment"> * i.e. with distinct locations separated by commas, semicolons or whitespace.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If not set, the implementation may use a default as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//处理单个资源文件路径为一个字符串的情况</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String CONFIG_LOCATION_DELIMITERS = &quot;,; /t/n&quot;;</span></span><br><span class="line">    <span class="comment">//即多个资源文件路径之间用” ,; \t\n”分隔，解析成数组形式</span></span><br><span class="line">    setConfigLocations(StringUtils.tokenizeToStringArray(location, CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the config locations for this application context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If not set, the implementation may use a default as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//解析Bean 定义资源文件的路径，处理多个资源文件字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">            <span class="comment">// resolvePath 为同一个类中将字符串解析为路径的方法</span></span><br><span class="line">            <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这两个方法的源码我们可以看出，我们既可以使用一个字符串来配置多个Spring Bean 配置信息，也可以使用字符串数组，即下面两种方式都是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;a.xml,b.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>多个资源文件路径之间可以是用” , ; \t\n”等分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res =<span class="keyword">new</span> ClassPathResource(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a.xml&quot;</span>,<span class="string">&quot;b.xml&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>至此，SpringIOC 容器在初始化时将配置的Bean 配置信息定位为Spring 封装的Resource。</p>
<h1 id="3、开始启动"><a href="#3、开始启动" class="headerlink" title="3、开始启动"></a>3、开始启动</h1><p>SpringIOC 容器对Bean 配置资源的载入是从refresh()函数开始的，refresh()是一个模板方法，规定了IOC 容器的启动流程， 有些逻辑要交给其子类去实现。它对Bean 配置资源进行载入ClassPathXmlApplicationContext 通过调用其父类AbstractApplicationContext 的refresh()函数启动整个IOC 容器对Bean 定义的载入过程，现在我们来详细看看refresh()中的逻辑处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">//1、调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">//2、告诉子类启动refreshBeanFactory()方法，Bean 定义资源文件的载入从</span></span><br><span class="line">        <span class="comment">//子类的refreshBeanFactory()方法启动</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">//3、为BeanFactory 配置容器特性，例如类加载器、事件处理器等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">//4、为容器的某些子类指定特殊的BeanPost 事件处理器</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">//5、调用所有注册的BeanFactoryPostProcessor 的Bean</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">//6、为BeanFactory 注册BeanPost 事件处理器.</span></span><br><span class="line">            <span class="comment">//BeanPostProcessor 是Bean 后置处理器，用于监听容器触发的事件</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">//7、初始化信息源，和国际化相关.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">//8、初始化容器事件传播器.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">//9、调用子类的某些特殊Bean 初始化方法</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">//10、为事件传播器注册事件监听器.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">//11、初始化所有剩余的单例Bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">//12、初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            <span class="comment">//13、销毁已创建的Bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            <span class="comment">//14、取消refresh 操作，重置容器的同步标识.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            <span class="comment">//15、重设公共缓存</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>refresh()方法主要为IOC 容器Bean 的生命周期管理提供条件，Spring IOC 容器载入Bean 配置信息从其子类容器的refreshBeanFactory() 方法启动， 所以整个refresh() 中“ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();”这句以后代码的都是注册容器的信息源和生命周期事件，我们前面说的载入就是从这句代码开始启动。</p>
<p>refresh()方法的主要作用是：在创建IOC 容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh 之后使用的是新建立起来的IOC 容器。它类似于对IOC 容器的重启，在新建立好的容器中对容器进行初始化，对Bean 配置资源进行载入。</p>
<h1 id="4、创建容器"><a href="#4、创建容器" class="headerlink" title="4、创建容器"></a>4、创建容器</h1><p>obtainFreshBeanFactory()方法调用子类容器的refreshBeanFactory()方法，启动容器载入Bean 配置信息的过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractApplicationContext 类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext 实现的refreshBeanFactory()方法，方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果已经有容器，销毁容器中的bean，关闭容器</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建IOC 容器</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">//对IOC 容器进行定制化，如设置启动参数，开启注解的自动装配等</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//调用载入Bean 定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions 方法，具体的实现调用子类容器</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，先判断BeanFactory 是否存在，如果存在则先销毁beans 并关闭beanFactory，接着创建DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean 定义。</p>
<h1 id="5、载入配置路径"><a href="#5、载入配置路径" class="headerlink" title="5、载入配置路径"></a>5、载入配置路径</h1><p>AbstractRefreshableApplicationContext 中只定义了抽象的loadBeanDefinitions 方法，容器真正调用的是其子类AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext的主要源码如下：<br>loadBeanDefinitions() 方法同样是抽象方法， 是由其子类实现的， 也即在AbstractXmlApplicationContext 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableConfigApplicationContext</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现父类抽象的载入Bean 定义方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建XmlBeanDefinitionReader，即创建Bean 读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean 配置资源</span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">        <span class="comment">//为Bean 读取器设置Spring 资源加载器，AbstractXmlApplicationContext 的</span></span><br><span class="line">        <span class="comment">//祖先父类AbstractApplicationContext 继承DefaultResourceLoader，因此，容器本身也是一个资源加载器</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//为Bean 读取器设置SAX xml 解析器</span></span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//当Bean 读取器读取Bean 定义的Xml 资源文件时，启用Xml 的校验机制</span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        <span class="comment">//Bean 读取器真正实现加载的方法</span></span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanDefinitionReader</span><span class="params">(XmlBeanDefinitionReader reader)</span> </span>&#123;</span><br><span class="line">        reader.setValidating(<span class="keyword">this</span>.validating);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Xml Bean 读取器加载Bean 配置资源</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取Bean 配置资源的定位</span></span><br><span class="line">        Resource[] configResources = getConfigResources();</span><br><span class="line">        <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Xml Bean 读取器调用其父类AbstractBeanDefinitionReader 读取定位的Bean 配置资源</span></span><br><span class="line">            reader.loadBeanDefinitions(configResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果子类中获取的Bean 配置资源定位为空，则获取ClassPathXmlApplicationContext</span></span><br><span class="line">        <span class="comment">// 构造方法中setConfigLocations 方法设置的资源</span></span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Xml Bean 读取器调用其父类AbstractBeanDefinitionReader 读取定位的Bean 配置资源</span></span><br><span class="line">            reader.loadBeanDefinitions(configLocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里又使用了一个委托模式，调用子类的获取Bean 配置资源定位的方法</span></span><br><span class="line">    <span class="comment">//该方法在ClassPathXmlApplicationContext 中进行实现，对于我们</span></span><br><span class="line">    <span class="comment">//举例分析源码的ClassPathXmlApplicationContext 没有使用该方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Resource[] getConfigResources() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以XmlBean 读取器的其中一种策略XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调用其父类AbstractBeanDefinitionReader 的reader.loadBeanDefinitions()方法读取Bean 配置资源。<br>由于我们使用ClassPathXmlApplicationContext 作为例子分析，因此getConfigResources 的返回值为null，因此程序执行reader.loadBeanDefinitions(configLocations)分支。</p>
<h1 id="6、分配路径处理策略"><a href="#6、分配路径处理策略" class="headerlink" title="6、分配路径处理策略"></a>6、分配路径处理策略</h1><p>在XmlBeanDefinitionReader 的抽象父类AbstractBeanDefinitionReader 中定义了载入过程。<br>AbstractBeanDefinitionReader 的loadBeanDefinitions()方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载方法，调用下面的loadBeanDefinitions(String, Set&lt;Resource&gt;);方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">//获取在IOC 容器初始化过程中设置的资源加载器</span></span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;Cannot import bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将指定位置的Bean 配置信息解析为Spring IOC 容器封装的资源</span></span><br><span class="line">            <span class="comment">//加载多个指定位置的Bean 配置信息</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="comment">//委派调用其子类XmlBeanDefinitionReader 的方法，实现加载功能</span></span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        <span class="comment">//将指定位置的Bean 配置信息解析为Spring IOC 容器封装的资源</span></span><br><span class="line">        <span class="comment">//加载单个指定位置的Bean 配置信息</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="comment">//委派调用其子类XmlBeanDefinitionReader 的方法，实现加载功能</span></span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载方法，调用loadBeanDefinitions(String);</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractRefreshableConfigApplicationContext 的loadBeanDefinitions(Resource…resources) 方法实际上是调用AbstractBeanDefinitionReader 的loadBeanDefinitions()方法。<br>从对AbstractBeanDefinitionReader 的loadBeanDefinitions()方法源码分析可以看出该方法就做了两件事：<br>首先，调用资源加载器的获取资源方法resourceLoader.getResource(location)，获取到要加载的资源。<br>其次，真正执行加载功能是其子类XmlBeanDefinitionReader 的loadBeanDefinitions()方法。在loadBeanDefinitions()方法中调用了AbstractApplicationContext 的getResources()方法，跟进去之后发现getResources()方法其实定义在ResourcePatternResolver 中，此时，我们有必要来看一下ResourcePatternResolver 的全类图：<br><img src="https://upload-images.jianshu.io/upload_images/24719542-17e22cf5186678b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/24719542-c14cf25265e3e677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从上面可以看到ResourceLoader 与ApplicationContext 的继承关系，可以看出其实际调用的是DefaultResourceLoader 中的getSource() 方法定位Resource ， 因为ClassPathXmlApplicationContext 本身就是DefaultResourceLoader 的实现类，所以此时又回到了ClassPathXmlApplicationContext 中来。</p>
<h1 id="7、解析配置文件路径"><a href="#7、解析配置文件路径" class="headerlink" title="7、解析配置文件路径"></a>7、解析配置文件路径</h1><p>XmlBeanDefinitionReader 通过调用ClassPathXmlApplicationContext 的父类DefaultResourceLoader 的getResource()方法获取要加载的资源<br>//TODO添加源码解析</p>
<h1 id="8、开始读取配置内容"><a href="#8、开始读取配置内容" class="headerlink" title="8、开始读取配置内容"></a>8、开始读取配置内容</h1><p>继续回到XmlBeanDefinitionReader 的loadBeanDefinitions(Resource …)方法看到代表bean 文件的资源定义以后的载入过程。<br>//TODO添加源码解析</p>
<h1 id="9、准备文档对象"><a href="#9、准备文档对象" class="headerlink" title="9、准备文档对象"></a>9、准备文档对象</h1><p>DocumentLoader 将Bean 配置资源转换成Document 对象<br>//TODO添加源码解析</p>
<h1 id="10、分配解析策略"><a href="#10、分配解析策略" class="headerlink" title="10、分配解析策略"></a>10、分配解析策略</h1><p>XmlBeanDefinitionReader 类中的doLoadBeanDefinition()方法是从特定XML 文件中实际载入Bean 配置资源的方法，该方法在载入Bean 配置资源之后将其转换为Document 对象，接下来调用registerBeanDefinitions() 启动Spring IOC 容器对Bean 定义的解析过程。<br>//TODO添加源码解析</p>
<h1 id="11、将配置载入内存"><a href="#11、将配置载入内存" class="headerlink" title="11、将配置载入内存"></a>11、将配置载入内存</h1><p>BeanDefinitionDocumentReader 接口通过registerBeanDefinitions() 方法调用其实现类DefaultBeanDefinitionDocumentReader 对Document 对象进行解析。<br>//TODO添加源码解析</p>
<h1 id="12、载入-lt-bean-gt-元素"><a href="#12、载入-lt-bean-gt-元素" class="headerlink" title="12、载入&lt; bean &gt;元素"></a>12、载入&lt; bean &gt;元素</h1><p>Bean 配置信息中的&lt; import &gt;和&lt; alias &gt;元素解析在DefaultBeanDefinitionDocumentReader 中已经完成，对Bean 配置信息中使用最多的<bean>元素交由BeanDefinitionParserDelegate 来解析。<br>//TODO添加源码解析</p>
<h1 id="13、载入-lt-property-gt-元素"><a href="#13、载入-lt-property-gt-元素" class="headerlink" title="13、载入&lt; property &gt;元素"></a>13、载入&lt; property &gt;元素</h1><p>BeanDefinitionParserDelegate 在解析&lt; Bean &gt;调用parsePropertyElements()方法解析&lt; Bean &gt;元素中的&lt; property &gt;属性子元素。<br>//TODO添加源码解析</p>
<h1 id="14、载入-lt-property-gt-的子元素"><a href="#14、载入-lt-property-gt-的子元素" class="headerlink" title="14、载入&lt; property &gt;的子元素"></a>14、载入&lt; property &gt;的子元素</h1><p>在BeanDefinitionParserDelegate 类中的parsePropertySubElement()方法对&lt; property &gt;中的子元素解析。<br>//TODO添加源码解析</p>
<h1 id="15、载入-lt-list-gt-的子元素"><a href="#15、载入-lt-list-gt-的子元素" class="headerlink" title="15、载入&lt; list &gt;的子元素"></a>15、载入&lt; list &gt;的子元素</h1><p>在BeanDefinitionParserDelegate 类中的parseListElement()方法就是具体实现解析&lt; property &gt;元素中的&lt; list &gt;集合子元素。<br>//TODO添加源码解析</p>
<h1 id="16、分配注册策略"><a href="#16、分配注册策略" class="headerlink" title="16、分配注册策略"></a>16、分配注册策略</h1><p>让我们继续跟踪程序的执行顺序，接下来我们来分析DefaultBeanDefinitionDocumentReader 对Bean 定义转换的Document 对象解析的流程中， 在其parseDefaultElement() 方法中完成对Document 对象的解析后得到封装BeanDefinition 的BeanDefinitionHold 对象， 然后调用BeanDefinitionReaderUtils 的registerBeanDefinition() 方法向IOC 容器注册解析的Bean 。</p>
<p>BeanDefinitionReaderUtils 的注册的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将解析的BeanDefinitionHold 注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">//获取解析的BeanDefinition 的名称</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">//向IOC 容器注册BeanDefinition</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    <span class="comment">//如果解析的BeanDefinition 有别名，向容器为其注册别名</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用BeanDefinitionReaderUtils 向IOC 容器注册解析的BeanDefinition 时，真正完成注册功能的是DefaultListableBeanFactory。</p>
<h1 id="17、向容器注册"><a href="#17、向容器注册" class="headerlink" title="17、向容器注册"></a>17、向容器注册</h1><p>DefaultListableBeanFactory 中使用一个HashMap 的集合对象存放IOC 容器中注册解析的BeanDefinition，向IOC 容器注册的主要源码如下：<br><img src="https://upload-images.jianshu.io/upload_images/24719542-7380c12d754ff550.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储注册信息的BeanDefinition</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向IOC 容器注册解析的BeanDefiniton</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">//校验解析的BeanDefiniton</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition oldBeanDefinition;</span><br><span class="line">    oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Cannot register bean definition [&quot;</span> + beanDefinition + <span class="string">&quot;] for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                            <span class="string">&quot;&#x27;: There is already [&quot;</span> + oldBeanDefinition + <span class="string">&quot;] bound.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        oldBeanDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.info(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + oldBeanDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">//注册的过程中需要线程同步，以保证数据的一致性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有同名的BeanDefinition 已经在IOC 容器中注册</span></span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">//重置所有已经注册过的BeanDefinition 的缓存</span></span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Bean 配置信息中配置的Bean 被解析过后，已经注册到IOC 容器中，被容器管理起来，真正完成了IOC 容器初始化所做的全部工作。现在IOC 容器中已经建立了整个Bean 的配置信息，这些BeanDefinition 信息已经可以使用，并且可以被检索，IOC 容器的作用就是对这些注册的Bean 定义信息进行处理和维护。这些的注册的Bean 定义信息是IOC 容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://halomzh.github.io/2020/09/18/Spring%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="halomzh">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="halomzh.github.io">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/Spring%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E7%B1%BB/" class="post-title-link" itemprop="url">Spring核心容器类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-18 12:51:14" itemprop="dateCreated datePublished" datetime="2020-09-18T12:51:14+08:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-25 17:37:43" itemprop="dateModified" datetime="2020-09-25T17:37:43+08:00">2020-09-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、BeanFactory"><a href="#1、BeanFactory" class="headerlink" title="1、BeanFactory"></a>1、BeanFactory</h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giz8ciljndj30ks0tcn4e.jpg" alt="image-20200922104151453"></p>
<p>其中BeanFactory 作为最顶层的一个接口类，它定义了IOC 容器的基本功能规范，BeanFactory 有三个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p>
<p>XmlBeanFactory继承自DefaultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是 Spring 注册及加载 bean 的默认实现，而对于 XmlBeanFactory 与DefaultListableBeanFactory 不同的地方其实是在 XmlBeanFactory 中使用了自定义的 XML读取器XmlBeanDefinitionReader，实现了个性化的BeanDefinitionReader读取，DefaultListableBeanFactory继承了 AbstractAutowireCapableBeanFactory 并实现了 ConfigurableListableBeanFactory 以及BeanDefinitionRegistry接口。</p>
<p><strong>AliasRegistry</strong>：定义对alias的简单增删改等操作。</p>
<p><strong>SimpleAliasRegistry</strong>：主要使用map作为alias的缓存，并对接口AliasRegistry进行实现。</p>
<p><strong>SingletonBeanRegistry</strong>：定义对单例的注册及获取。</p>
<p><strong>BeanFactory</strong>：定义获取bean及bean的各种属性。</p>
<p><strong>DefaultSingletonBeanRegistry</strong>：对接口SingletonBeanRegistry各函数的实现。</p>
<p><strong>HierarchicalBeanFactory</strong>：继承BeanFactory，也就是在BeanFactory定义的功能的基础上增加了对parentFactory的支持。</p>
<p><strong>BeanDefinitionRegistry</strong>：定义对BeanDefinition的各种增删改操作。</p>
<p><strong>FactoryBeanRegistrySupport</strong>：在DefaultSingletonBeanRegistry基础上增加了对FactoryBean的特殊处理功能。</p>
<p><strong>ConfigurableBeanFactory</strong>：提供配置Factory的各种方法。</p>
<p><strong>ListableBeanFactory</strong>：根据各种条件获取bean的配置清单。</p>
<p><strong>AbstractBeanFactory</strong>：综合 FactoryBeanRegistrySupport和 ConfigurableBeanFactory的功能。</p>
<p><strong>AutowireCapableBeanFactory</strong>：提供创建bean、自动注入、初始化以及应用bean的后处理器。</p>
<p><strong>AbstractAutowireCapableBeanFactory</strong>：综合AbstractBeanFactory并对接口Autowire Capable BeanFactory进行实现。</p>
<p><strong>ConfigurableListableBeanFactory</strong>：BeanFactory配置清单，指定忽略类型及接口等。</p>
<p><strong>DefaultListableBeanFactory</strong>：综合上面所有功能，主要是对Bean注册后的处理。</p>
<h2 id="1、ListableBeanFactory-接口表示这些Bean-是可列表化的"><a href="#1、ListableBeanFactory-接口表示这些Bean-是可列表化的" class="headerlink" title="1、ListableBeanFactory 接口表示这些Bean 是可列表化的"></a>1、ListableBeanFactory 接口表示这些Bean 是可列表化的</h2><p><img src="https://upload-images.jianshu.io/upload_images/24719542-4abb36abff2b0ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="2、HierarchicalBeanFactory-表示的是这些Bean-是有继承关系的，也就是每个Bean-有可能有父Bean"><a href="#2、HierarchicalBeanFactory-表示的是这些Bean-是有继承关系的，也就是每个Bean-有可能有父Bean" class="headerlink" title="2、HierarchicalBeanFactory 表示的是这些Bean 是有继承关系的，也就是每个Bean 有可能有父Bean"></a>2、HierarchicalBeanFactory 表示的是这些Bean 是有继承关系的，也就是每个Bean 有可能有父Bean</h2><p><img src="https://upload-images.jianshu.io/upload_images/24719542-22a0f789f8bc1c6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="3、AutowireCapableBeanFactory-接口定义Bean-的自动装配规则"><a href="#3、AutowireCapableBeanFactory-接口定义Bean-的自动装配规则" class="headerlink" title="3、AutowireCapableBeanFactory 接口定义Bean 的自动装配规则"></a>3、AutowireCapableBeanFactory 接口定义Bean 的自动装配规则</h2><p><img src="https://upload-images.jianshu.io/upload_images/24719542-c46ef2c592dba6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这三个接口共同定义了Bean 的集合、Bean 之间的关系、以及Bean 行为。</p>
<p>在BeanFactory 里只对IOC 容器的基本行为作了定义，根本不关心你的Bean 是如何定义怎样加载的。</p>
<p>而要知道工厂是如何产生对象的，我们需要看具体的IOC 容器实现，Spring 提供了许多IOC 容器的实现。比如GenericApplicationContext ， ClasspathXmlApplicationContext 等。</p>
<h1 id="2、BeanDefinition"><a href="#2、BeanDefinition" class="headerlink" title="2、BeanDefinition"></a>2、BeanDefinition</h1><p>SpringIOC 容器管理了我们定义的各种Bean 对象及其相互的关系，Bean 对象在Spring 实现中是以BeanDefinition 来描述的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24719542-7373a5c6418ae465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>BeanDefinition 是一个接口，在 Spring 中存在三种实现：<strong>RootBeanDefinition</strong>、<strong>ChildBeanDefinition</strong> 以及 b。三种实现均继承了 <strong>AbstractBeanDefiniton</strong> ，其中BeanDefinition 是配置文件&lt; bean &gt;元素标签在容器中的内部表示形式。&lt; bean &gt;元素标签拥有class、scope、lazy-init等配置属性，BeanDefinition则提供了相应的beanClass、scope、lazyInit属性，BeanDefinition和&lt; bean &gt;中的属性是一一对应的。其中<strong>RootBeanDefinition</strong>是最常用的实现类，它对应一般性的&lt; bean &gt;元素标签，<strong>GenericBeanDefinition</strong>是自2.5版本以后新加入的bean文件配置属性定义类，是一站式服务类。<br>在配置文件中可以定义父&lt; bean &gt;和子&lt; bean &gt;，<strong>父&lt; bean &gt;用RootBeanDefinition表示</strong>，而<strong>子&lt; bean &gt;用ChildBeanDefiniton表示</strong>，而没有父&lt; bean &gt;的&lt; bean &gt;就使用RootBeanDefinition表示。AbstractBeanDefinition对两者共同的类信息进行抽象。”</p>
<h1 id="3、BeanDefinitionReader"><a href="#3、BeanDefinitionReader" class="headerlink" title="3、BeanDefinitionReader"></a>3、BeanDefinitionReader</h1><p>Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/24719542-7802218e5157371d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p>
<h1 id="注册解析的BeanDefinition"><a href="#注册解析的BeanDefinition" class="headerlink" title="注册解析的BeanDefinition"></a>注册解析的BeanDefinition</h1><p>对于配置文件，解析也解析完了，装饰也装饰完了，对于得到的beanDinition已经可以满足后续的使用要求了，唯一还剩下的工作就是注册了，也就是processBeanDefinition函数中的BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,getReaderContext().getRegistry())代码的解析了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">   <span class="comment">//	用beanName作为唯一标识注册</span></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">   <span class="comment">// 注册所有别名</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，解析的beanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中，而对于beanDefinition的注册分成了两部分：通过beanName的注册以及通过别名的注册。</p>
<h2 id="1．通过beanName注册BeanDefinition"><a href="#1．通过beanName注册BeanDefinition" class="headerlink" title="1．通过beanName注册BeanDefinition"></a>1．通过beanName注册BeanDefinition</h2><p>对于 beanDefinition 的注册，或许很多人认为的方式就是将 beanDefinition 直接放入 map中就好了，使用 beanName 作为 key。确实，Spring 就是这么做的，只不过除此之外，它还做了点别的事情。</p>
<p>在对于bean的注册处理方式上，主要进行了几个步骤。</p>
<p>（1）对AbstractBeanDefinition的校验。在解析XML文件的时候我们提过校验，但是此校验非彼校验，之前的校验时针对于 XML 格式的校验，而此时的校验时针是对于 AbstractBean Definition的methodOverrides属性的。</p>
<p>（2）对beanName已经注册的情况的处理。如果设置了不允许bean的覆盖，则需要抛出异常，否则直接覆盖。</p>
<p>（3）加入map缓存。</p>
<p>（4）清除解析之前留下的对应beanName的缓存。</p>
<h2 id="2．通过别名注册BeanDefinition"><a href="#2．通过别名注册BeanDefinition" class="headerlink" title="2．通过别名注册BeanDefinition"></a>2．通过别名注册BeanDefinition</h2><p>注册alias的步骤如下。</p>
<p>（1）alias与beanName相同情况处理。若alias与beanName并名称相同则不需要处理并删除掉原有alias。</p>
<p>（2）alias覆盖处理。若aliasName已经使用并已经指向了另一beanName则需要用户的设置进行处理。</p>
<p>（3）alias循环检查。当A-&gt;B存在时，若再次出现A-&gt;C-&gt;B时候则会抛出异常。</p>
<p>（4）注册alias。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">halomzh</p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">halomzh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
